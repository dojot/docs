# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, CPqD
# This file is distributed under the same license as the dojot package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: dojot 0.4.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-09-15 10:12-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../source/internal-communication.rst:2
msgid "Internal communication"
msgstr "Comunicação interna"

#: ../../source/internal-communication.rst:4
msgid "This page describes how each service in dojot communicate with each other."
msgstr "Esta página descreve como cada serviço na dojot se comunica."

#: ../../source/internal-communication.rst:8
msgid "Components"
msgstr "Componentes"

#: ../../source/internal-communication.rst:10
msgid ""
"The main components current in dojot are shown in "
":numref:`dojot_components`."
msgstr ""
"Os principais componentes atuais na dojot são mostrados em "
":numref:`dojot_components`."

#: ../../source/internal-communication.rst:13
msgid "dojot components"
msgstr "Componentes da Dojot"

#: ../../source/internal-communication.rst:47
msgid "They are:"
msgstr "Eles são:"

#: ../../source/internal-communication.rst:49
msgid "Auth: authentication mechanism"
msgstr "Auth: mecanismo de autenticação"

#: ../../source/internal-communication.rst:50
msgid "DeviceManager: device and template storage."
msgstr "DeviceManager: armazenamento de dispositivo e modelo."

#: ../../source/internal-communication.rst:51
msgid "Persister: component that stores all device-generated data."
msgstr ""
"Persister: componente que armazena todos os dados gerados pelo "
"dispositivo."

#: ../../source/internal-communication.rst:52
msgid "History: component that exposes all device-generated data."
msgstr "History: componente que expõe todos os dados gerados pelo dispositivo."

#: ../../source/internal-communication.rst:53
msgid ""
"DataBroker: deals with subjects and Kafka topics, as well as socket.io "
"connections."
msgstr ""
"DataBroker: lida com assuntos e tópicos do Kafka, além de conexões "
"socket.io."

#: ../../source/internal-communication.rst:55
msgid "Flowbroker: handles flows (both CRUD and flow execution)"
msgstr "Flowbroker: lida com fluxos (CRUD e execução de fluxo)"

#: ../../source/internal-communication.rst:56
msgid "IoT agents: agents for different protocols."
msgstr "IoT agents: agentes para diferentes protocolos."

#: ../../source/internal-communication.rst:59
msgid ""
"Each service will be briefly described in this page. More information can"
" be found in each component documentation."
msgstr ""
"Cada serviço será descrito brevemente nesta página. Mais informações "
"podem ser encontradas na documentação de cada componente."

#: ../../source/internal-communication.rst:63
msgid "Messaging and authentication"
msgstr "Mensagens e autenticação"

#: ../../source/internal-communication.rst:65
msgid ""
"There are two methods through which dojot components can talk to each "
"other: via HTTP REST requests and via Kafka. They are intended for "
"different purposes, though."
msgstr ""
"Existem dois meios pelos quais os componentes dojot podem se comunicar: "
"via solicitações HTTP REST e via Kafka. Eles são destinados a diferentes "
"propósitos."

#: ../../source/internal-communication.rst:69
msgid ""
"HTTP requests can be sent at boot time when a component want, for "
"instance, information about particular resources, such as list of devices"
" or tenants. For that, they must know which component has which resource "
"in order to retrieve them correctly. This means - and this is a very "
"important thing that drives architectural choices in dojot - that only a "
"single service is responsible for retrieving data models for a particular"
" resource (note that a service might have multiple instances, though). "
"For example, DeviceManager is responsible for storing and retrieving "
"information model for devices and templates, FlowBroker for flow "
"descriptions, History for historical data, and so on."
msgstr ""
"As solicitações HTTP podem ser enviadas no momento da inicialização "
"quando um componente deseja, por exemplo, informações sobre recursos "
"específicos, como lista de dispositivos ou *tenants*. Para isso, eles "
"devem saber qual componente possui qual recurso para recuperá-los "
"corretamente. Isso significa - e isso é muito importante porque conduz as"
" escolhas arquiteturais na dojot - que apenas um único serviço é "
"responsável por recuperar modelos de dados para um recurso específico "
"(observe que um serviço pode ter várias instâncias). Por exemplo, o "
"DeviceManager é responsável por armazenar e recuperar o modelo de "
"informações para dispositivos e modelos, FlowBroker para descrições de "
"fluxo, Histórico para dados históricos e assim por diante."

#: ../../source/internal-communication.rst:79
msgid ""
"Kafka, in the other hand, allows loosely coupled communication between "
"instances of services. This means that a producer (whoever sends a "
"message) does not know which components will receive its message. "
"Furthermore, any consumer doesn't know who generated the message that it "
"being ingested. This allows data to be transmitted based on "
"\"interests\": a consumer is interested in ingesting messages with a "
"particular `subject` (more on that later) and producers will send "
"messages to all components that are interested in it. Note that this "
"mechanism allows multiple services to emit messages with the same "
"\"subject\", as well as multiple services ingesting messages with the "
"same \"subject\" with no tricky workarounds whatsoever."
msgstr ""
"Kafka, por outro lado, permite uma comunicação pouco acoplada entre "
"instâncias de serviços. Isso significa que um produtor (quem envia uma "
"mensagem) não sabe quais componentes receberão sua mensagem. Além disso, "
"qualquer consumidor não sabe quem gerou a mensagem de que está sendo "
"ingerido. Isso permite que os dados sejam transmitidos com base em "
"\"interesses\": um consumidor está interessado em receber mensagens com "
"um determinado assunto (mais sobre isso mais tarde) e os produtores "
"enviarão mensagens para todos os componentes que estiverem interessados "
"nele. Observe que esse mecanismo permite que vários serviços emitam "
"mensagens com o mesmo \"assunto\", bem como vários serviços que ingerem "
"mensagens com o mesmo \"assunto\", sem soluções alternativas complicadas."

#: ../../source/internal-communication.rst:92
msgid "Sending HTTP requests"
msgstr "Enviando solicitações HTTP"

#: ../../source/internal-communication.rst:94
msgid ""
"In order to send requests via HTTP, a service must create an access "
"token, described here. There is no further considerations beyond "
"following the API description associated to each service. This can be "
"seen in figure :numref:`initial_authentication`. Note that all "
"interactions depicted here are abstractions of the actual ones. Also, it "
"should be noted that these interactions are valid only for internal "
"components. Any external service should use Kong as entrypoint."
msgstr ""
"Para enviar solicitações via HTTP, um serviço deve criar um token de "
"acesso, descrito aqui. Não há outras considerações além de seguir a "
"descrição da API associada a cada serviço. Isso pode ser visto na figura"
"  :numref:`initial_authentication`. Observe que todas as interações "
"descritas aqui são abstrações das reais. Além disso, deve-se notar que "
"essas interações são válidas apenas para componentes internos. Qualquer "
"serviço externo deve usar o Kong como ponto de entrada."

#: ../../source/internal-communication.rst:103
msgid "Initial authentication"
msgstr "Autenticação inicial"

#: ../../source/internal-communication.rst:118
msgid ""
"In this figure, a client retrieves an access token for user `admin` whose"
" password is `p4ssw0rd`. After that, a user can send a request to HTTP "
"APIs using it. This is shown in :numref:`sending_requests`. Note: the "
"actual authorization mechanism is detailed in `Auth + API gateway "
"(Kong)`_."
msgstr ""
"Nesta figura, um cliente recupera um token de acesso para o administrador"
" do usuário cuja senha é p4ssw0rd. Depois disso, um usuário pode enviar "
"uma solicitação para as APIs HTTP usando-o. Isso é mostrado na Fig. "
":numref:`sending_requests`. Nota: o mecanismo de autorização real é "
"detalhado `Auth + API gateway (Kong)`_."

#: ../../source/internal-communication.rst:124
msgid "Sending messages to HTTP API"
msgstr "Enviando mensagens para a API HTTP"

#: ../../source/internal-communication.rst:147
msgid ""
"In this figure, a client creates a new device using the token retrieved "
"in :numref:`initial_authentication`. This request is analyzed by Kong, "
"which will invoke Auth to check whether the user set in the token is "
"allowed to ``POST`` to ``/device`` endpoint. Only after the approval of "
"such request, Kong will forward it to DeviceManager."
msgstr ""
"Nesta figura, um cliente cria um novo dispositivo usando o token "
"recuperado em :numref:`initial_authentication`. Essa solicitação é "
"analisada por Kong, que chamará Auth para verificar se o usuário definido"
" no token tem permissão para ``POST`` para o terminal ``/device``. "
"Somente após a aprovação dessa solicitação, Kong a encaminhará para o "
"DeviceManager."

#: ../../source/internal-communication.rst:155
msgid "Sending Kafka messages"
msgstr "Enviando mensagens via Kafka"

#: ../../source/internal-communication.rst:157
msgid ""
"Kafka uses a quite different approach. Each message should be associated "
"to a subject and a tenant. This is show in :numref:`retrieving_topics`;"
msgstr ""
"Kafka usa uma abordagem bem diferente. Cada mensagem deve ser associada a"
" um assunto e um inquilino. Isso é mostrado na "
":numref:`retrieving_topics`;"

#: ../../source/internal-communication.rst:161
msgid "Retrieving Kafka topics"
msgstr "Recuperando tópicos do Kafka"

#: ../../source/internal-communication.rst:201
msgid ""
"In this example, DeviceManager needs to publish a message about a new "
"device. In order to do so, it sends a request to DataBroker, indicating "
"which tenant (within JWT token) and which subject (``dojot.device-"
"manager.devices``) it wants to use to send the message. DataBroker will "
"invoke Redis to check whether this topic is already created and check "
"whether dojot administrator had created a profile to this particular "
"tuple ``{tenant, subject}``."
msgstr ""
"Neste exemplo, o DeviceManager precisa publicar uma mensagem sobre um "
"novo dispositivo. Para isso, ele envia uma solicitação ao DataBroker, "
"indicando qual *tenant* (dentro do token JWT) e qual assunto (``dojot"
".device-manager.devices``) deseja usar para enviar a mensagem. O "
"DataBroker chamará o Redis para verificar se este tópico já foi criado e "
"se o administrador dojot criou um perfil para essa tupla específica "
"``{tenant, subject}``."

#: ../../source/internal-communication.rst:208
msgid ""
"The two profile schemes available are shown in :numref:`automatic_scheme`"
" and :numref:`assigned_scheme`."
msgstr ""
"Os dois esquemas de perfis disponíveis são mostrados na "
":numref:`automatic_scheme` e na :numref:`assigned_scheme`."

#: ../../source/internal-communication.rst:212
msgid "Automatic scheme profile"
msgstr "Perfil de esquema automático"

#: ../../source/internal-communication.rst:221
msgid ""
"The automatic scheme set the number of Kafka partitions to be used to the"
" topic being created, as well as the replication factor (how many "
"replicas will be there for each topic partition). It's up to Kafka to "
"decide which partition and replica will be assigned to which broker "
"instance. You can check `Kafka partitions and replicas`_ in order to know"
" a bit more about partition and replicas. Of course you can check "
"`Kafka's official documentation`_."
msgstr ""
"O esquema automático define o número de partições Kafka a serem usadas "
"para o tópico que está sendo criado, bem como o fator de replicação "
"(quantas réplicas estarão disponíveis para cada partição de tópico). Cabe"
" a Kafka decidir qual partição e réplica será atribuída a qual instância "
"do broker. Você pode verificar `Kafka partitions and replicas`_ para "
"conhecer um pouco mais sobre partição e réplicas. Claro que você pode "
"conferir a `Kafka's official documentation`_."

#: ../../source/internal-communication.rst:229
msgid "Assigned scheme profile"
msgstr "Perfil de esquema atribuído"

#: ../../source/internal-communication.rst:238
msgid ""
"The assigned scheme indicates which partition will be allocated to which "
"Kafka instance. This includes also replicas (partitions with more than "
"one associated Kafka instance)."
msgstr ""
"O esquema atribuído indica qual partição será alocada para qual instância"
" Kafka. Isso inclui também réplicas (partições com mais de uma instância "
"Kafka associada)."

#: ../../source/internal-communication.rst:243
msgid "Bootstrapping tenants"
msgstr "Inicialização dos *tenants*"

#: ../../source/internal-communication.rst:245
msgid ""
"All components are interested in a set of subjects, which will be used to"
" either send messages or receive messages from Kafka. As dojot groups "
"Kafka topics and tenants into subjects (a subject will be composed by one"
" or more Kafka topics, each one transmitting messages for a particular "
"tenant), the component must bootstrap each tenant before sending or "
"receiving messages. This is done in two phases: component boot time and "
"component runtime."
msgstr ""
"Todos os componentes estão interessados em um conjunto de assuntos, que "
"serão usados para enviar ou receber mensagens de Kafka. Como a dojot "
"agrupa  tópicos do Kafka e tenants em assuntos (um assunto será composto "
"por um ou mais tópicos Kafka, cada um transmitindo mensagens para um "
"tenant específico), o componente deve iniciar cada tenant antes de enviar"
" ou receber mensagens. Isso é feito em duas fases: tempo de inicialização"
" do componente e tempo de execução do componente."

#: ../../source/internal-communication.rst:252
msgid ""
"In the first phase, a component asks Auth in order to retrieve all "
"currently configured tenants. It is interested, let's say, in consuming "
"messages from `device-data` and `dojot.device-manager.devices` subjects. "
"Therefore, it will request DataBroker a topic for each tenant for each "
"subject. With that list of topics, it can create Producers and Consumers "
"to send and receives messages through those topics. This is shown by "
":numref:`Tenant bootstrapping startup`."
msgstr ""
"Na primeira fase, um componente solicita ao Auth para recuperar todos os "
"*tenants* configurados no momento. Está interessado, digamos, em consumir"
" mensagens dos assuntos device-data e dojot.device-manager.devices. "
"Portanto, ele solicitará ao DataBroker um tópico para cada *tenant* para "
"cada assunto. Com essa lista de tópicos, ele pode criar Produtores e "
"Consumidores para enviar e receber mensagens através desses tópicos. Isso"
" é mostrado na :numref:`Tenant bootstrapping startup`."

#: ../../source/internal-communication.rst:260
msgid "Tenant bootstrapping at startup"
msgstr "Inicialização do *tenants* no início"

#: ../../source/internal-communication.rst:284
msgid ""
"The second phase starts after startup and its purpose is to process all "
"messages received through Kafka. This will include any tenant that is "
"created after all services are up and running. :numref:`Tenant "
"bootstrapping` shows how to deal with these messages."
msgstr ""
"A segunda fase inicia após a inicialização e seu objetivo é processar "
"todas as mensagens recebidas pelo Kafka. Isso incluirá qualquer *tenant* "
"criado após todos os serviços estarem em funcionamento. :numref:`Tenant "
"bootstrapping` mostra como lidar com essas mensagens."

#: ../../source/internal-communication.rst:290
msgid "Tenant bootstrapping"
msgstr "Inicialização do *tenant*"

#: ../../source/internal-communication.rst:318
msgid ""
"All services that are somehow interested in using subjects should execute"
" this procedure in order to correctly receive all messages."
msgstr ""
"Todos os serviços que estão de alguma forma interessados em usar assuntos"
" devem executar este procedimento para receber corretamente todas as "
"mensagens."

#: ../../source/internal-communication.rst:323
msgid "Auth + API gateway (Kong)"
msgstr ""

#: ../../source/internal-communication.rst:325
msgid ""
"Auth is a service deeply connected to Kong. It is responsible for user "
"management, authentication and authorization. As such, it is invoked by "
"Kong whenever an request is received by one of its registered endpoints. "
"This section will detail how this is performed and how they work "
"together."
msgstr ""
"Auth é um serviço profundamente conectado ao Kong. É responsável pelo "
"gerenciamento, autenticação e autorização do usuário. Como tal, é "
"invocado por Kong sempre que uma solicitação é recebida por um de seus "
"pontos de um dos endpoints. Esta seção detalha como isso é realizado e "
"como eles funcionam juntos."

#: ../../source/internal-communication.rst:331
msgid "Kong configuration"
msgstr "Configuração do Kong"

#: ../../source/internal-communication.rst:333
msgid "There are two configuration procedures when starting Kong within dojot:"
msgstr "Existem dois procedimentos de configuração ao iniciar o Kong na dojot:"

#: ../../source/internal-communication.rst:335
msgid "Migrating existing data"
msgstr "Migrando Dados Existentes"

#: ../../source/internal-communication.rst:336
msgid "Registering API endpoints and plugins."
msgstr "Registrando endpoints e plug-ins de API."

#: ../../source/internal-communication.rst:338
msgid "The first task is performed by simply invoking Kong with a special flag."
msgstr ""
"A primeira tarefa é realizada simplesmente invocando Kong com uma "
"bandeira especial."

#: ../../source/internal-communication.rst:340
msgid ""
"The second one is performed by executing a configuration script "
"`kong.config.sh`. Its only purpose is to register endpoints in Kong, such"
" as:"
msgstr ""
"O segundo é executado executando um script de configuração "
"kong.config.sh. Seu único objetivo é registrar endpoints no Kong, como:"

#: ../../source/internal-communication.rst:358
msgid ""
"This command will register the endpoint `/device/*/latest` and "
"`/subscription` and all requests to it are going to be forwarded to `http"
"//data-broker:80`. You can check the documentation on how to add "
"endpoints in `Kong's documentation`_."
msgstr ""
"Este comando registrará o  endpoint `/dispositivo/*/latest` e "
"`/subscription` e todas as solicitações serão encaminhadas para `http"
"//data-broker:80`. Você pode verificar a documentação sobre como "
"adicionar endpoints na `Kong's documentation`_."

#: ../../source/internal-communication.rst:362
msgid ""
"For some of its registered endpoints, `kong.config.sh` will add two "
"plugins to selected endpoints:"
msgstr ""
"Para alguns dos endpoints registrados, o kong.config.sh adicionará dois "
"plug-ins aos endpoints selecionados:"

#: ../../source/internal-communication.rst:365
msgid ""
"JWT generation. The documentation for this plugin is available at `Kong "
"JWT plugin page`_."
msgstr ""
"Geração JWT. A documentação para este plugin está disponível na `Kong JWT"
" plugin page`_."

#: ../../source/internal-communication.rst:367
msgid ""
"Configuration a plugin which will forward all policies requests to Auth. "
"will invoke Auth in order to authenticate requests. This plugin is "
"available in `PEP-Kong repository`_."
msgstr ""
"Configure um plug-in que encaminhará todas as solicitações de para o "
"Auth. invocará Auth para autenticar solicitações. Este plugin está "
"disponível no `PEP-Kong repository`_."

#: ../../source/internal-communication.rst:371
msgid "The following request install these two plugins in data-broker API:"
msgstr "A solicitação a seguir instala esses dois plug-ins na API do data-broker:"

#: ../../source/internal-communication.rst:381
msgid "Emitted messages"
msgstr "Mensagens emitidas"

#: ../../source/internal-communication.rst:383
msgid "Auth will emit just one message via Kafka for tenant creation:"
msgstr "O Auth emitirá apenas uma mensagem via Kafka para a criação do tenant:"

#: ../../source/internal-communication.rst:393
msgid "Device Manager"
msgstr "Device Manager"

#: ../../source/internal-communication.rst:395
msgid ""
"DeviceManager stores and retrieves information models for devices and "
"templates and a few static information about them as well. Whenever a "
"device is created, removed or just edited, it will publish a message "
"through Kafka. It depends only on DataBroker and Kafka for reasons "
"already explained in this document."
msgstr ""
"O DeviceManager armazena e recupera modelos de informações para "
"dispositivos e modelos e algumas informações estáticas sobre eles também."
" Sempre que um dispositivo é criado, removido ou apenas editado, ele "
"publica uma mensagem no Kafka. Depende apenas do DataBroker e Kafka pelos"
" motivos já explicados neste documento."

#: ../../source/internal-communication.rst:400
msgid ""
"All messages published by Device Manager to Kafka can be seen in `Device "
"Manager messages`_."
msgstr ""
"Todas as mensagens publicadas pelo Device Manager no Kafka podem ser "
"vistas no Device Manager `Device Manager mensagens`_."

#: ../../source/internal-communication.rst:404
msgid "IoT agent"
msgstr "Agente IoT"

#: ../../source/internal-communication.rst:406
msgid ""
"IoT agents receive messages from devices and translate them into a "
"default message to be published to other components. In order to do that,"
" they might want to know which devices are created in order to properly "
"filter messages which are not allowed into dojot (using, for instance, "
"security information to block messages from unauthorized devices). It "
"will use the ``device-data`` subject and bootstrap tenants as described "
"in `Bootstrapping tenants`_."
msgstr ""
"Os agentes de IoT recebem mensagens de dispositivos e os convertem em uma"
" mensagem padrão a ser publicada em outros componentes. Para fazer isso, "
"eles podem querer saber quais dispositivos são criados para filtrar "
"corretamente as mensagens que não são permitidas na dojot (usando, por "
"exemplo, informações de segurança para bloquear mensagens de dispositivos"
" não autorizados). Ele usará o assunto ``device-data`` e a inicialização "
"de *tenants*, conforme descrito em `Inicialização dos tenants`_."

#: ../../source/internal-communication.rst:413
msgid ""
"After requesting the topics for all tenants within `device-data` subject,"
" IoT agent will start receiving data from devices. As there are a "
"plethora of ways by which devices can do that, this step won't be "
"detailed in this section (this is highly dependent on how each IoT agent "
"works). It must, though, send a message to Kafka to inform other "
"components of all new data that the device just sent. This is shown in "
":numref:`IoT agent - kafka`."
msgstr ""
"Após solicitar os tópicos para todos os *tenants* no assunto `device-"
"data`, o agente da IoT começará a receber dados dos dispositivos. Como há"
" várias maneiras pelas quais os dispositivos podem fazer isso, esta etapa"
" não será detalhada nesta seção (isso depende muito de como cada agente "
"de IoT funciona). No entanto, ele deve enviar uma mensagem para Kafka "
"para informar outros componentes de todos os novos dados que o "
"dispositivo acabou de enviar. Isso é mostrado na :numref:`IoT agent - "
"kafka`"

#: ../../source/internal-communication.rst:421
msgid "IoT agent message to Kafka"
msgstr "Mensagem do agente de IoT para Kafka"

#: ../../source/internal-communication.rst:431
msgid ""
"The data sent by IoT agent has the structure shown in :numref:`IoT agent "
"message`."
msgstr ""
"Os dados enviados pelo agente de IoT têm a estrutura mostrada na "
":numref:`IoT agent message`."

#: ../../source/internal-communication.rst:435
msgid "IoT agent message structure"
msgstr "Estrutura de mensagens do agente IoT"

#: ../../source/internal-communication.rst:453
msgid "Such message would be:"
msgstr "Essa mensagem seria:"

#: ../../source/internal-communication.rst:472
#: ../../source/internal-communication.rst:482
msgid "Persister"
msgstr ""

#: ../../source/internal-communication.rst:474
msgid ""
"Persister is a very simple service which only purpose is to receive "
"messages from devices (using ``device-data`` subject) and store them into"
" MongoDB. For that, the bootstrapping procedure (detailed in "
"`Bootstrapping tenants`_) is performed and, whenever a new message is "
"received, it will create a new Mongo document and store it into the "
"device's collection. This is shown in :numref:`Persister`."
msgstr ""
"Persister é um serviço muito simples, cujo único objetivo é receber "
"mensagens dos dispositivos (usando o assunto ``device-data``) e "
"armazená-las no MongoDB. Para isso, é realizado o procedimento de "
"inicialização (detalhado em `Inicialização dos tenants`_) e, sempre que "
"uma nova mensagem é recebida, ele cria um novo documento Mongo e o "
"armazena na coleção do dispositivo. Isso é mostrado na "
":numref:`Persister`."

#: ../../source/internal-communication.rst:495
msgid "This service is simple as it is by design."
msgstr "Este serviço é simples, pois é por design."

#: ../../source/internal-communication.rst:498
#: ../../source/internal-communication.rst:505
msgid "History"
msgstr ""

#: ../../source/internal-communication.rst:500
msgid ""
"History is also a very simple service: whenever a user or application "
"sends a request to it, it will query MongoDB and build a proper message "
"to send back to the user/application. This is shown in :numref:`History`."
msgstr ""
"O histórico também é um serviço muito simples: sempre que um usuário ou "
"aplicativo envia uma solicitação, ele consulta o MongoDB e cria uma "
"mensagem adequada para enviar de volta ao usuário/aplicativo. Isso é "
"mostrado na :numref:`History`."

#: ../../source/internal-communication.rst:528
msgid "Data Broker"
msgstr ""

#: ../../source/internal-communication.rst:530
msgid ""
"DataBroker has a few more functionalities than only generating topics for"
" ``{tenant, subject}`` pairs. It will also serve socket.io connections to"
" emit messages in real time. In order to do so, it retrieves all topics "
"for `device-data` subject, just as in any other component interested in "
"data received from devices. As soon as it receives a message, it will "
"then forward it to a 'room' (using socket.io vocabulary) associated to "
"the device and to the associated tenant. Thus, all client connected to it"
" (such as graphical user interfaces) will receive a new message "
"containing all the received data. For more information about how to open "
"a socket.io connection with DataBroker, check `DataBroker "
"documentation`_."
msgstr ""
"O DataBroker possui algumas funcionalidades a mais do que apenas gerar "
"tópicos para pares ``{tenant, subject}``. Ele também servirá conexões "
"socket.io para emitir mensagens em tempo real. Para fazer isso, ele "
"recupera todos os tópicos para o assunto `device-data`, assim como em "
"qualquer outro componente interessado nos dados recebidos dos "
"dispositivos. Assim que receber uma mensagem, ela será encaminhada para "
"uma 'sala' (usando o vocabulário socket.io) associada ao dispositivo e ao"
" *tenant* associado. Portanto, todo cliente conectado a ele (como "
"interfaces gráficas de usuário) receberá uma nova mensagem contendo todos"
" os dados recebidos. Para obter mais informações sobre como abrir uma "
"conexão socket.io com o DataBroker, consulte a `Documentação do "
"DataBroker`_."

#: ../../source/internal-communication.rst:543
msgid "Certificate authority"
msgstr "Autoridade Certificadora"

#: ../../source/internal-communication.rst:545
msgid ""
"The dojot has an internal *Certificate Authority* (`CA`_) capable of "
"issuing x.509 certificates so that devices can communicate with the "
"platform through a secure channel (using the TLS protocol). When "
"requesting a certificate for the platform, it is necessary to inform a "
"`CSR`_, which will go through a series of validations until arriving at "
"the internal Certificate Authority, which, in turn, if all checks pass "
"successfully, will sign a certificate and link this certificate to the "
"device registration. The ``x509-identity-mgmt`` component is responsible "
"for providing certificate-related services for devices."
msgstr ""
"A plataforma dojot possui internamente uma autoridade certificadora "
"(`CA`_) capaz de emitir certificados x.509 para que os dispositivos "
"possam se comunicar com a plataforma através de um canal seguro (usando o"
" protocolo TLS). Ao requisitar um certificado para a plataforma, é "
"necessário informar um `CSR`_, o qual passará por uma série de validações"
" até chegar na Autoridade Certificadora interna, que por sua vez, se "
"todas as verificações passarem com sucesso, assinará um certificado e "
"vinculará este certificado ao registro do dispositivo. O componente "
"``x509-identity-mgmt`` é responsável por oferecer os serviços "
"relacionados a certificados para dispositivos."

#: ../../source/internal-communication.rst:556
msgid "Kafka-WS"
msgstr ""

#: ../../source/internal-communication.rst:558
msgid ""
"*Kafka WebSocket* allows the users to retrieve data from a given dojot"
"topic in a Kafka cluster, this retrieval can be conditional and/or partial."
"It works with pure websocket connections, so you can create websocket"
"clients in any language you want as long as they support RFC 6455."

msgstr ""
"O serviço *Kafka WebSocket* permite aos usuários a recuperação de dados "
"de um topico da dojot em um Cluster Kafka, essa recuperação pode ser conticional e/ou parcial. "
"Funciona com uma conexão websocket pura, para que clientes websocket possam ser criados "
"em qualquer linguagem que tenha suporte para o RFC 6455."

#: ../../source/internal-communication.rst:563
msgid "Connecting to the service"
msgstr "Conectando com o serviço"

#: ../../source/internal-communication.rst:566
msgid ""
"The connection is done in two steps, you must first obtain a single-use ticket "
"through a REST request, then, be authorized to connect to the service through "
"a websocket. "
msgstr ""
"A conexão é realizada em dois passos, primeiro obtendo um ticket de uso único "
"mediante uma requisição REST, depois ser autorizado para conectar com o serviço via "
"websocket"

#: ../../source/internal-communication.rst:570
msgid "First step: Get the single-use ticket"
msgstr "Primeiro passo: obter um ticket de uso único"

#: ../../source/internal-communication.rst:572
msgid ""
"A ticket allows the user to subscribe to a dojot topic. To obtain it is necessary "
"to have a JWT access token that is issued by the platform's Authentication/Authorization "
"service. Ticket request must be made by REST at the endpoint <base-url>/kafka-ws/v1/ticket " 
"using the HTTP GET verb. The request must contain the header Authorization and the "
"JWT token as value, according to the syntax:"
msgstr ""
"Um ticket permite que o usúario se subscrever com um topico da dojot. Para obter o ticket é necessário "
"ter um token JWT gerado pelo serviço de Autenticação/Autorização da plataforma. "
"a requisição REST do ticket deve ser redirecionada para o endpoint <base-url>/kafka-ws/v1/ticket "
"usando o verbo HTTP GET. A requisição deve ter o cabeçalho Authorization"

"e o token JWT como valor, no seguinte formato:"


#: ../../source/internal-communication.rst:581
msgid "The component responds with the following syntax:"
msgstr "O componente responde com a seguinte sintaxe:"

#: ../../source/internal-communication.rst:591
msgid ""
"Note: In the context of a dojot deployment the JWT Token is provided by the Auth service,"
"and is validated by the API Gateway before redirecting the connection to the *Kafka-WS.*"
"So, no validations are done by the Kafka WS."
msgstr ""  
"Nota: No contexto de um deployment da dojot, o token é providenciado pelo serviço de Autenticação "
"e é validado pelo Gateway API antes de redirecionar a conexão para o *Kafka-WS.* "
"Portanto, nenhuma validação é feita pelo Kafka WS."

#: ../../source/internal-communication.rst:595
msgid "Second step: Establish a websocket connection"
msgstr "Segundo passo: Estabelecer a conexão websocket"

#: ../../source/internal-communication.rst:597
msgid ""
"The connection is done via pure websockets using the URI *<base-url>/kafka-ws/v1/topics/:topic*."
"You must pass the previously generated ticket as a parameter of this URI. It is also possible"
"to pass conditional and filter options as parameters of the URI."
msgstr ""
"A conexão é feita via websocket pura, usando a URI *<base-url>/kafka-ws/v1/topics/:topic*. "
"Você deve passar o ticket gerado anteriormente como parametro para esta URI. Também é possivel "
"passar opções e filtros condicionais como parâmetros para esta URI."

#: ../../source/internal-communication.rst:601
msgid "Behavior when requesting a ticket and a websocket connection"
msgstr "Comportamento ao solicitar um ticket e uma conexão websocket"

#: ../../source/internal-communication.rst:604
msgid ""
"Below we can understand the behavior of the Kafka-WS service when a user "
"(through a `user agent`_) requests a ticket in order to establish a "
"communication via websocket with Kafka-WS."
msgstr ""
"Abaixo podemos entender o comportamento do serviço Kafka-WS quando um "
"usuário (por meio de um `user agent`_) solicita um ticket para "
"estabelecer uma comunicação via websocket com Kafka-WS."

#: ../../source/internal-communication.rst:608
msgid ""
"Note that when the user requests a new ticket, Kafka-WS extracts some "
"information from the *user's access token* (`JWT`_) and generates a "
"*signed payload*, to be used later in the decision to authorize (or not) "
"the websocket connection. From the payload a *ticket* is generated and "
"both are stored in Redis, where the ticket is the key to obtain the "
"payload. A `TTL`_ is defined by Kafka-WS, so the user has to use the "
"ticket within the established time, otherwise, Redis automatically "
"deletes the ticket and payload."
msgstr ""
"Observe que quando o usuário solicita um novo ticket, o Kafka-WS extrai "
"algumas informações do *token de acesso do usuário* (`JWT`_) e gera um "
"*payload assinado*, para ser usado posteriormente na decisão de autorizar"
" (ou não) a conexão via websocket. A partir do payload, é gerado um "
"*ticket* e os dois são armazenados no Redis, onde o ticket é a chave para"
" obter o payload. Um `TTL`_ é definido pelo Kafka-WS, então o usuário "
"deve usar o ticket dentro do tempo estabelecido, caso contrário, o Redis "
"apaga automaticamente o ticket e o payload."

#: ../../source/internal-communication.rst:616
msgid ""
"After obtaining the ticket, the user makes an HTTP request to Kafka-WS "
"requesting an upgrade to communicate via *websocket*. As the "
"specification of this HTTP request limits the use of additional headers, "
"it is necessary to send the ticket through the URL, so that it can be "
"validated by Kafka-WS before authorizing the upgrade."
msgstr ""
"Após obter o ticket, o usuário faz uma solicitação HTTP ao Kafka-WS "
"requisitando um upgrade de protocolo para se comunicar via *websocket*. "
"Como a especificação dessa solicitação HTTP limita o uso de cabeçalhos "
"adicionais, é necessário enviar o ticket pela URL, para que possa ser "
"validado pelo Kafka-WS antes de autorizar o upgrade."

#: ../../source/internal-communication.rst:622
msgid ""
"Since the ticket is valid, that is, it corresponds to an entry on Redis, "
"Kafka-WS retrieves the payload related to the ticket, verifies the "
"integrity of the payload and deletes that entry on Redis so that the "
"ticket cannot be used again."
msgstr ""
"Dado que o ticket esteja válido ou seja, corresponde a uma entrada no "
"Redis, o Kafka-WS recupera o payload relacionado ao ticket, verifica sua "
"integridade e exclui essa entrada no Redis para que o ticket "
"não possa ser usado novamente."

#: ../../source/internal-communication.rst:627
msgid ""
"With the payload it is possible to make the decision to authorize the "
"upgrade to websocket or not. If authorization is granted, Kafka-WS opens "
"a subscription channel based on a specific topic in Kafka. From there, "
"the upgrade to websocket is established and the user starts to receive "
"data as they are being published in Kafka."
msgstr ""
"Com o payload é possível tomar a decisão de autorizar ou não o upgrade "
"para websocket. Se a autorização for concedida, o Kafka-WS abre um canal "
"de subscrição com base em um tópico específico no Kafka. A partir daí, o "
"upgrade para websocket é estabelecido e o usuário começa a receber os "
"dados à medida que vão sendo publicados no Kafka."

#: ../../source/internal-communication.rst:634
msgid "Obtaining a ticket and connecting via websocket"
msgstr "Obtenção de ticket e conexão via websocket"

#~ msgid "dojot components"
#~ msgstr "componentes dojot"

#~ msgid "They are:"
#~ msgstr "Eles são:"

#~ msgid "The main current dojot components are:"
#~ msgstr "Os principais componentes atuais da dojot são:"

#~ msgid "Current dojot components are shown in :numref:`dojot_components`."
#~ msgstr ""

#~ msgid "Kafka-ws"
#~ msgstr ""

