# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, CPqD
# This file is distributed under the same license as the dojot package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: dojot 0.4.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-09-22 16:43-0300\n"
"PO-Revision-Date: 2020-09-22 17:25-0300\n"
"Last-Translator: \n"
"Language: pt_BR\n"
"Language-Team: \n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"X-Generator: Poedit 2.4.1\n"

#: ../../source/internal-communication.rst:2
msgid "Internal communication"
msgstr "Comunicação interna"

#: ../../source/internal-communication.rst:4
msgid "This page describes how each service in dojot communicate with each other."
msgstr "Esta página descreve como cada serviço na dojot se comunica."

#: ../../source/internal-communication.rst:8
msgid "Components"
msgstr "Componentes"

#: ../../source/internal-communication.rst:10
msgid ""
"The main components current in dojot are shown in :numref:`dojot_components`."
msgstr ""
"Os principais componentes atuais na dojot são mostrados em :numref:"
"`dojot_components`."

#: ../../source/internal-communication.rst:13
msgid "dojot components"
msgstr "Componentes da Dojot"

#: ../../source/internal-communication.rst:47
msgid "They are:"
msgstr "Eles são:"

#: ../../source/internal-communication.rst:49
msgid "Auth: authentication mechanism"
msgstr "Auth: mecanismo de autenticação"

#: ../../source/internal-communication.rst:50
msgid "DeviceManager: device and template storage."
msgstr "DeviceManager: armazenamento de dispositivo e modelo."

#: ../../source/internal-communication.rst:51
msgid "Persister: component that stores all device-generated data."
msgstr ""
"Persister: componente que armazena todos os dados gerados pelo dispositivo."

#: ../../source/internal-communication.rst:52
msgid "History: component that exposes all device-generated data."
msgstr "History: componente que expõe todos os dados gerados pelo dispositivo."

#: ../../source/internal-communication.rst:53
msgid ""
"DataBroker: deals with subjects and Kafka topics, as well as socket.io "
"connections."
msgstr ""
"DataBroker: lida com *subjects* e tópicos do Kafka, além de conexões socket.io."

#: ../../source/internal-communication.rst:55
msgid "Flowbroker: handles flows (both CRUD and flow execution)"
msgstr "Flowbroker: lida com fluxos (CRUD e execução de fluxo)"

#: ../../source/internal-communication.rst:56
msgid "IoT agents: agents for different protocols."
msgstr "IoT agents: agentes para diferentes protocolos."

#: ../../source/internal-communication.rst:59
msgid ""
"Each service will be briefly described in this page. More information can be "
"found in each component documentation."
msgstr ""
"Cada serviço será descrito brevemente nesta página. Mais informações podem ser "
"encontradas na documentação de cada componente."

#: ../../source/internal-communication.rst:63
msgid "Messaging and authentication"
msgstr "Mensagens e autenticação"

#: ../../source/internal-communication.rst:65
msgid ""
"There are two methods through which dojot components can talk to each other: via "
"HTTP REST requests and via Kafka. They are intended for different purposes, "
"though."
msgstr ""
"Existem dois meios pelos quais os componentes dojot podem se comunicar: via "
"solicitações HTTP REST e via Kafka. Eles são destinados a diferentes propósitos."

#: ../../source/internal-communication.rst:69
msgid ""
"HTTP requests can be sent at boot time when a component want, for instance, "
"information about particular resources, such as list of devices or tenants. For "
"that, they must know which component has which resource in order to retrieve "
"them correctly. This means - and this is a very important thing that drives "
"architectural choices in dojot - that only a single service is responsible for "
"retrieving data models for a particular resource (note that a service might have "
"multiple instances, though). For example, DeviceManager is responsible for "
"storing and retrieving information model for devices and templates, FlowBroker "
"for flow descriptions, History for historical data, and so on."
msgstr ""
"As solicitações HTTP podem ser enviadas no momento da inicialização quando um "
"componente deseja, por exemplo, informações sobre recursos específicos, como "
"lista de dispositivos ou *tenants*. Para isso, eles devem saber qual componente "
"possui qual recurso para recuperá-los corretamente. Isso significa - e isso é "
"muito importante porque conduz as escolhas arquiteturais na dojot - que apenas "
"um único serviço é responsável por recuperar modelos de dados para um recurso "
"específico (observe que um serviço pode ter várias instâncias). Por exemplo, o "
"DeviceManager é responsável por armazenar e recuperar o modelo de informações "
"para dispositivos e modelos, FlowBroker para descrições de fluxo, History para "
"dados históricos e assim por diante."

#: ../../source/internal-communication.rst:79
msgid ""
"Kafka, in the other hand, allows loosely coupled communication between instances "
"of services. This means that a producer (whoever sends a message) does not know "
"which components will receive its message. Furthermore, any consumer doesn't "
"know who generated the message that it being ingested. This allows data to be "
"transmitted based on \"interests\": a consumer is interested in ingesting "
"messages with a particular `subject` (more on that later) and producers will "
"send messages to all components that are interested in it. Note that this "
"mechanism allows multiple services to emit messages with the same \"subject\", "
"as well as multiple services ingesting messages with the same \"subject\" with "
"no tricky workarounds whatsoever."
msgstr ""
"Kafka, por outro lado, permite uma comunicação pouco acoplada entre instâncias "
"de serviços. Isso significa que um produtor (quem envia uma mensagem) não sabe "
"quais componentes receberão sua mensagem. Além disso, qualquer consumidor não "
"sabe quem gerou a mensagem de que está sendo consumida. Isso permite que os dados "
"sejam transmitidos com base em \"interesses\": um consumidor está interessado em "
"receber mensagens com um determinado assunto (*subject*) (mais sobre isso mais tarde) e os "
"produtores enviarão mensagens para todos os componentes que estiverem "
"interessados nele. Observe que esse mecanismo permite que vários serviços emitam "
"mensagens com o mesmo \"assunto\" (*subject*), bem como vários serviços que consomem "
"mensagens com o mesmo \"assunto\" (*subject*), sem soluções alternativas complicadas."

#: ../../source/internal-communication.rst:92
msgid "Sending HTTP requests"
msgstr "Enviando solicitações HTTP"

#: ../../source/internal-communication.rst:94
msgid ""
"In order to send requests via HTTP, a service must create an access token, "
"described here. There is no further considerations beyond following the API "
"description associated to each service. This can be seen in figure :numref:"
"`initial_authentication`. Note that all interactions depicted here are "
"abstractions of the actual ones. Also, it should be noted that these "
"interactions are valid only for internal components. Any external service should "
"use Kong as entrypoint."
msgstr ""
"Para enviar solicitações via HTTP, um serviço deve criar um *token* de acesso, "
"descrito aqui. Não há outras considerações além de seguir a descrição da API "
"associada a cada serviço. Isso pode ser visto na figura  :numref:"
"`initial_authentication`. Observe que todas as interações descritas aqui são "
"abstrações das reais. Além disso, deve-se notar que essas interações são válidas "
"apenas para componentes internos. Qualquer serviço externo deve usar o Kong como "
"ponto de entrada."

#: ../../source/internal-communication.rst:103
msgid "Initial authentication"
msgstr "Autenticação inicial"

#: ../../source/internal-communication.rst:118
msgid ""
"In this figure, a client retrieves an access token for user `admin` whose "
"password is `p4ssw0rd`. After that, a user can send a request to HTTP APIs using "
"it. This is shown in :numref:`sending_requests`. Note: the actual authorization "
"mechanism is detailed in `Auth + API gateway (Kong)`_."
msgstr ""
"Nesta figura, um cliente recupera um *token* de acesso para o usuário `admin` "
"cuja senha é p4ssw0rd. Depois disso, um usuário pode enviar uma solicitação para "
"as APIs HTTP usando-o. Isso é mostrado na Fig. :numref:`sending_requests`. Nota: "
"o mecanismo de autorização real é detalhado `Auth + API gateway (Kong)`_."

#: ../../source/internal-communication.rst:124
msgid "Sending messages to HTTP API"
msgstr "Enviando mensagens para a API HTTP"

#: ../../source/internal-communication.rst:147
msgid ""
"In this figure, a client creates a new device using the token retrieved in :"
"numref:`initial_authentication`. This request is analyzed by Kong, which will "
"invoke Auth to check whether the user set in the token is allowed to ``POST`` to "
"``/device`` endpoint. Only after the approval of such request, Kong will forward "
"it to DeviceManager."
msgstr ""
"Nesta figura, um cliente cria um novo dispositivo usando o *token* recuperado "
"em :numref:`initial_authentication`. Essa solicitação é analisada pelo Kong, que "
"chamará o Auth para verificar se o usuário definido no *token* tem permissão para "
"``POST`` para o *endpoint* ``/device``. Somente após a aprovação dessa "
"solicitação, o Kong a encaminhará para o DeviceManager."

#: ../../source/internal-communication.rst:157
msgid "Sending Kafka messages"
msgstr "Enviando mensagens via Kafka"

#: ../../source/internal-communication.rst:159
msgid ""
"Kafka uses a quite different approach. Each message should be associated to a "
"subject and a tenant. This is show in :numref:`retrieving_topics`;"
msgstr ""
"Kafka usa uma abordagem bem diferente. Cada mensagem deve ser associada a um "
"*subject* e um *tenant*. Isso é mostrado na :numref:`retrieving_topics`;"

#: ../../source/internal-communication.rst:163
msgid "Retrieving Kafka topics"
msgstr "Recuperando tópicos do Kafka"

#: ../../source/internal-communication.rst:192
msgid ""
"In this example, DeviceManager needs to publish a message about a new device. In "
"order to do so, it sends a request to DataBroker, indicating which tenant "
"(within JWT token) and which subject (``dojot.device-manager.devices``) it wants "
"to use to send the message."
msgstr ""
"Neste exemplo, o DeviceManager precisa publicar uma mensagem sobre um novo "
"dispositivo. Para isso, ele envia uma solicitação ao DataBroker, indicando qual "
"*tenant* (dentro do token JWT) e qual *subject* (``dojot.device-manager.devices``) "
"deseja usar para enviar a mensagem."

#: ../../source/internal-communication.rst:197
msgid ""
"To better understand how it all works, you can check the `Data Broker` "
"documentation for the component and API, the links are in :doc:`./components-and-"
"apis`."
msgstr ""
"Para entender melhor como tudo funciona, você pode verificar a documentação do "
"`Data Broker` para o componente e API, os links estão em  :doc:`./components-and-"
"apis`."

#: ../../source/internal-communication.rst:205
msgid "Bootstrapping tenants"
msgstr "Inicialização dos *tenants*"

#: ../../source/internal-communication.rst:207
msgid ""
"All components are interested in a set of subjects, which will be used to either "
"send messages or receive messages from Kafka. As dojot groups Kafka topics and "
"tenants into subjects (a subject will be composed by one or more Kafka topics, "
"each one transmitting messages for a particular tenant), the component must "
"bootstrap each tenant before sending or receiving messages. This is done in two "
"phases: component boot time and component runtime."
msgstr ""
"Todos os componentes estão interessados em um conjunto de *subjects*, que serão "
"usados para enviar ou receber mensagens do Kafka. Como a dojot agrupa  tópicos "
"do Kafka e tenants em *subjects* (um *subjects* será composto por um ou mais "
"tópicos Kafka, cada um transmitindo mensagens para um *tenant* específico), o "
"componente deve iniciar cada *tenant* antes de enviar ou receber mensagens. Isso "
"é feito em duas fases: tempo de inicialização do componente e tempo de execução "
"do componente."

#: ../../source/internal-communication.rst:214
msgid ""
"In the first phase, a component asks Auth in order to retrieve all currently "
"configured tenants. It is interested, let's say, in consuming messages from "
"`device-data` and `dojot.device-manager.devices` subjects. Therefore, it will "
"request DataBroker a topic for each tenant for each subject. With that list of "
"topics, it can create Producers and Consumers to send and receives messages "
"through those topics. This is shown by :numref:`Tenant bootstrapping startup`."
msgstr ""
"Na primeira fase, um componente solicita ao Auth para recuperar todos os "
"*tenants* configurados no momento. Está interessado, digamos, em consumir "
"mensagens dos *subject* `device-data` e `dojot.device-manager.devices`. "
"Portanto, ele solicitará ao DataBroker um tópico para cada *tenant* para cada "
"*subject*. Com essa lista de tópicos, ele pode criar Produtores e Consumidores "
"para enviar e receber mensagens através desses tópicos. Isso é mostrado em :"
"numref:`Tenant bootstrapping startup`."

#: ../../source/internal-communication.rst:222
msgid "Tenant bootstrapping at startup"
msgstr "Inicialização do *tenants* no início"

#: ../../source/internal-communication.rst:244
msgid ""
"The second phase starts after startup and its purpose is to process all messages "
"received through Kafka subscribing in ``dojot-management.dojot.tenancy``. This "
"will include any tenant that is created after all services are up and running. :"
"numref:`Tenant bootstrapping` shows how to deal with these messages."
msgstr ""
"A segunda fase inicia após a inicialização e seu objetivo é processar todas as "
"mensagens recebidas pelo Kafka se subscrevendo no tópico ``dojot-management."
"dojot.tenancy``. Isso incluirá qualquer *tenant* criado após todos os serviços "
"estarem em funcionamento. :numref:`Tenant bootstrapping` mostra como lidar com "
"essas mensagens."

#: ../../source/internal-communication.rst:251
msgid "Tenant bootstrapping"
msgstr "Inicialização do *tenant*"

#: ../../source/internal-communication.rst:277
msgid ""
"All services that are somehow interested in using subjects should execute this "
"procedure in order to correctly receive all messages."
msgstr ""
"Todos os serviços que estão de alguma forma interessados em usar *subjects* "
"devem executar este procedimento para receber corretamente todas as mensagens."

#: ../../source/internal-communication.rst:281
msgid "Auth + API gateway (Kong)"
msgstr ""

#: ../../source/internal-communication.rst:283
msgid ""
"Auth is a service deeply connected to Kong. It is responsible for user "
"management, authentication and authorization. As such, it is invoked by Kong "
"whenever an request is received by one of its registered endpoints. This section "
"will detail how this is performed and how they work together."
msgstr ""
"Auth é um serviço profundamente conectado ao Kong. É responsável pelo "
"gerenciamento, autenticação e autorização do usuário. Como tal, é invocado pelo "
"Kong sempre que uma solicitação é recebida por um de seus"
"*endpoints* registrados. Esta seção detalha como isso é realizado e como eles funcionam "
"juntos."

#: ../../source/internal-communication.rst:289
msgid "Kong configuration"
msgstr "Configuração do Kong"

#: ../../source/internal-communication.rst:291
msgid "There are two configuration procedures when starting Kong within dojot:"
msgstr "Existem dois procedimentos de configuração ao iniciar o Kong na dojot:"

#: ../../source/internal-communication.rst:293
msgid "Migrating existing data"
msgstr "Migrando Dados Existentes"

#: ../../source/internal-communication.rst:294
msgid "Registering API endpoints and plugins."
msgstr "Registrando endpoints e plugins de API."

#: ../../source/internal-communication.rst:296
msgid "The first task is performed by simply invoking Kong with a special flag."
msgstr ""
"A primeira tarefa é realizada simplesmente invocando o Kong com uma *flag* "
"especial."

#: ../../source/internal-communication.rst:298
msgid ""
"The second one is performed by executing a configuration script after starting "
"Kong. Its only purpose is to register endpoints in Kong, such as:"
msgstr ""
"O segundo é executando um *script* de configuração. Seu único objetivo é "
"registrar *endpoints* no Kong, tal como:"

#: ../../source/internal-communication.rst:316
msgid ""
"These commands will register the endpoint `/device/*/latest` and `/subscription` "
"and all requests to it are going to be forwarded to `http//data-broker:80`. You "
"can check the documentation on how to add endpoints in Kong's documentation. The "
"links are in the :doc:`./components-and-apis` page."
msgstr ""
"Este comando registrará o  *endpoint* `/dispositivo/*/latest` e `/subscription` "
"e todas as solicitações serão encaminhadas para `http//data-broker:80`. Você "
"pode verificar a documentação sobre como adicionar *endpoints* na documentação "
"do Kong em :doc:`./components-and-apis`."

#: ../../source/internal-communication.rst:321
msgid ""
"For some of its registered endpoints, the script will add two plugins to "
"selected endpoints:"
msgstr ""
"Para alguns dos *endpoints registrados*, o *script* adicionará dois *plugins* "
"aos *endpoints* selecionados:"

#: ../../source/internal-communication.rst:324
msgid ""
"JWT generation. The documentation for this plugin is available at `Kong JWT "
"plugin page`_."
msgstr ""
"Geração JWT. A documentação para este *plugin* está disponível na `Kong JWT "
"plugin page`_."

#: ../../source/internal-communication.rst:326
msgid ""
"Configuration a plugin which will forward all policies requests to Auth in order "
"to authenticate requests. This plugin is available inside the `Kong repository`_."
msgstr ""
"Configura um *plugin* que encaminhará todas as solicitações para o Auth para "
"autenticar solicitações. Este *plugin* está disponível dentro do  `Kong "
"repository`_."

#: ../../source/internal-communication.rst:330
msgid "The following request install these two plugins in data-broker API:"
msgstr "A solicitação a seguir instala esses dois *plugins* na API do data-broker:"

#: ../../source/internal-communication.rst:347
msgid "Emitted messages"
msgstr "Mensagens emitidas"

#: ../../source/internal-communication.rst:349
msgid "Auth will emit just one message via Kafka for tenant creation:"
msgstr "O Auth emitirá apenas uma mensagem via Kafka para a criação do *tenant*:"

#: ../../source/internal-communication.rst:358
msgid "And one for tenant deletion:"
msgstr "E uma para exclusão do *tenant*:"

#: ../../source/internal-communication.rst:367
msgid ""
"By default these messages are created in kafka topic ``dojot-management.dojot."
"tenancy``."
msgstr ""
"Por padrão, essas mensagens são criadas no tópico ``dojot-management.dojot."
"tenancy`` do Kafka."

#: ../../source/internal-communication.rst:370
msgid ""
"This prefix topic can be configured, check the`Auth` component documentation :"
"doc:`./components-and-apis`."
msgstr ""
"Este prefixo do tópico pode ser configurado, verifique a documentação do "
"componente`Auth` em :doc:`./components-and-apis`."

#: ../../source/internal-communication.rst:374
msgid "Device Manager"
msgstr "Device Manager"

#: ../../source/internal-communication.rst:376
msgid ""
"DeviceManager stores and retrieves information models for devices and templates "
"and a few static information about them as well. Whenever a device is created, "
"removed or just edited, it will publish a message through Kafka. It depends only "
"on DataBroker and Kafka for reasons already explained in this document."
msgstr ""
"O DeviceManager armazena e recupera modelos de informações para dispositivos e "
"modelos e algumas informações estáticas sobre eles também. Sempre que um "
"dispositivo é criado, removido ou apenas editado, ele publica uma mensagem no "
"Kafka. Depende apenas do DataBroker e Kafka pelos motivos já explicados neste "
"documento."

#: ../../source/internal-communication.rst:381
msgid ""
"The `DeviceManager` documentation on GitHub ReadMe explains in more depth all "
"messages published. You can find the link in :doc:`./components-and-apis`."
msgstr ""
"A documentação do `DeviceManager` no GitHub ReadMe explica com mais detalhes "
"todas as mensagens publicadas. Você pode encontrar o link em: "
" :doc:`./components-and-apis`."

#: ../../source/internal-communication.rst:386
msgid "IoT agent"
msgstr "Agente IoT"

#: ../../source/internal-communication.rst:388
msgid ""
"IoT agents receive messages from devices and translate them into a default "
"message to be published to other components. In order to do that, they might "
"want to know which devices are created in order to properly filter messages "
"which are not allowed into dojot (using, for instance, security information to "
"block messages from unauthorized devices). It will use the ``device-data`` "
"subject and bootstrap tenants as described in `Bootstrapping tenants`_."
msgstr ""
"Os agentes de IoT recebem mensagens de dispositivos e os convertem em uma "
"mensagem padrão a ser publicada em outros componentes. Para fazer isso, eles "
"podem querer saber quais dispositivos são criados para filtrar corretamente as "
"mensagens que não são permitidas na dojot (usando, por exemplo, informações de "
"segurança para bloquear mensagens de dispositivos não autorizados). Ele usará o "
"*subject* ``device-data`` e a inicialização de *tenants*, conforme descrito em "
"`Inicialização dos tenants`_."

#: ../../source/internal-communication.rst:395
msgid ""
"After requesting the topics for all tenants within `device-data` subject, IoT "
"agent will start receiving data from devices. As there are a plethora of ways by "
"which devices can do that, this step won't be detailed in this section (this is "
"highly dependent on how each IoT agent works). It must, though, send a message "
"to Kafka to inform other components of all new data that the device just sent. "
"This is shown in :numref:`IoT agent - kafka`, in this case we are using the "
"tenant `admin`."
msgstr ""
"Após solicitar os tópicos para todos os *tenants* no *subject* `device-data`, o "
"agente IoT começará a receber dados dos dispositivos. Como há várias maneiras "
"pelas quais os dispositivos podem fazer isso, esta etapa não será detalhada "
"nesta seção (isso depende muito de como cada agente de IoT funciona). No "
"entanto, ele deve enviar uma mensagem para Kafka para informar outros "
"componentes de todos os novos dados que o dispositivo acabou de enviar. Isso é "
"mostrado na :numref:`IoT agent - kafka`, neste caso, estamos usando o *tenant* "
"`admin`."

#: ../../source/internal-communication.rst:404
msgid "IoT agent message to Kafka"
msgstr "Mensagem do agente de IoT para Kafka"

#: ../../source/internal-communication.rst:414
msgid ""
"The data sent by IoT agent has the structure shown in :numref:`IoT agent "
"message`."
msgstr ""
"Os dados enviados pelo agente de IoT têm a estrutura mostrada na :numref:`IoT "
"agent message`."

#: ../../source/internal-communication.rst:418
msgid "IoT agent message structure"
msgstr "Estrutura de mensagens do agente IoT"

#: ../../source/internal-communication.rst:436
msgid "Such message would be:"
msgstr "Essa mensagem seria:"

#: ../../source/internal-communication.rst:455
#: ../../source/internal-communication.rst:465
msgid "Persister"
msgstr ""

#: ../../source/internal-communication.rst:457
msgid ""
"Persister is a very simple service which only purpose is to receive messages "
"from devices (using ``device-data`` subject) and store them into MongoDB. For "
"that, the bootstrapping procedure (detailed in `Bootstrapping tenants`_) is "
"performed and, whenever a new message is received, it will create a new Mongo "
"document and store it into the device's collection. This is shown in :numref:"
"`Persister`, in this case we are using tenant admin."
msgstr ""
"Persister é um serviço muito simples, cujo único objetivo é receber mensagens "
"dos dispositivos (usando o *subject* ``device-data``) e armazená-las no MongoDB. "
"Para isso, é realizado o procedimento de inicialização (detalhado em "
"`Bootstrapping tenants`_) e,  sempre que uma nova mensagem é recebida, ele cria "
"um novo documento Mongo e o armazena na coleção do dispositivo."

#: ../../source/internal-communication.rst:478
msgid "This service is simple as it is by design."
msgstr "Este serviço é simples, pois é por design."

#: ../../source/internal-communication.rst:481
#: ../../source/internal-communication.rst:488
msgid "History"
msgstr ""

#: ../../source/internal-communication.rst:483
msgid ""
"History is also a very simple service: whenever a user or application sends a "
"request to it, it will query MongoDB and build a proper message to send back to "
"the user/application. This is shown in :numref:`History`."
msgstr ""
"O History também é um serviço muito simples: sempre que um usuário ou "
"aplicativo envia uma solicitação, ele consulta o MongoDB e cria uma mensagem "
"adequada para enviar de volta ao usuário/aplicativo. Isso é mostrado na :numref:"
"`History`."

#: ../../source/internal-communication.rst:511
msgid "Data Broker"
msgstr ""

#: ../../source/internal-communication.rst:513
msgid ""
"DataBroker has a few more functionalities than only generating topics for "
"``{tenant, subject}`` pairs. It will also serve socket.io connections to emit "
"messages in real time. In order to do so, it retrieves all topics for `device-"
"data` subject, just as in any other component interested in data received from "
"devices. As soon as it receives a message, it will then forward it to a "
"'room' (using socket.io vocabulary) associated to the device and to the "
"associated tenant. Thus, all client connected to it (such as graphical user "
"interfaces) will receive a new message containing all the received data. For "
"more information about how to open a socket.io connection with DataBroker, check "
"DataBroker documentation in :doc:`./components-and-apis`."
msgstr ""
"O DataBroker possui algumas funcionalidades a mais do que apenas gerar tópicos "
"para pares ``{tenant, subject}``. Ele também servirá conexões socket.io para "
"emitir mensagens em tempo real. Para fazer isso, ele recupera todos os tópicos "
"para o *subject* `device-data`, assim como em qualquer outro componente "
"interessado nos dados recebidos dos dispositivos. Assim que receber uma "
"mensagem, ela será encaminhada para uma 'sala' (usando o vocabulário socket.io) "
"associada ao dispositivo e ao *tenant* associado. Portanto, todo cliente "
"conectado a ele (como interfaces gráficas de usuário) receberão uma nova "
"mensagem contendo todos os dados recebidos. Para obter mais informações sobre "
"como abrir uma conexão socket.io com o DataBroker, consulte a documentação da "
"*API* do DataBroker em :doc:`./components-and-apis`."

#: ../../source/internal-communication.rst:525
msgid ""
"The real time socket.io connections via Data Broker will be discontinued in "
"future releases. Use `Kafka-WS`_ instead."
msgstr ""
"As conexões socket.io em tempo real via Data Broker serão descontinuadas em "
"versões futuras. Use o `Kafka-WS`_ ao invés dele."

#: ../../source/internal-communication.rst:529
msgid "Certificate authority"
msgstr "Autoridade Certificadora"

#: ../../source/internal-communication.rst:531
msgid ""
"The dojot has an internal *Certificate Authority* (`CA`_) capable of issuing "
"x.509 certificates so that devices can communicate with the platform through a "
"secure channel (using the TLS protocol). When requesting a certificate for the "
"platform, it is necessary to inform a `CSR`_, which will go through a series of "
"validations until arriving at the internal Certificate Authority, which, in "
"turn, if all checks pass successfully, will sign a certificate and link this "
"certificate to the device registration. The `x509-identity-mgmt` component is "
"responsible for providing certificate-related services for devices."
msgstr ""
"A plataforma dojot possui internamente uma autoridade certificadora (`CA`_) "
"capaz de emitir certificados x.509 para que os dispositivos possam se comunicar "
"com a plataforma através de um canal seguro (usando o protocolo TLS). Ao "
"requisitar um certificado para a plataforma, é necessário informar um `CSR`_, o "
"qual passará por uma série de validações até chegar na Autoridade Certificadora "
"interna, que por sua vez, se todas as verificações passarem com sucesso, "
"assinará um certificado e vinculará este certificado ao registro do dispositivo. "
"O componente `x509-identity-mgmt` é responsável por oferecer os serviços "
"relacionados a certificados para dispositivos."

#: ../../source/internal-communication.rst:544
msgid "Kafka-WS"
msgstr ""

#: ../../source/internal-communication.rst:546
msgid ""
"*Kafka WebSocket* service allows the users to retrieve conditional and/or "
"partial real time data from a given dojot topic in its internal Kafka cluster."
msgstr ""
"O serviço *Kafka WebSocket* permite aos usuários a recuperação parcial e/ou "
"condicional de dados em tempo real de um determinado tópico do cluster Kafka "
"interno da dojot."

#: ../../source/internal-communication.rst:550
msgid "Behavior when requesting a ticket and a websocket connection"
msgstr "Comportamento ao solicitar um ticket e uma conexão websocket"

#: ../../source/internal-communication.rst:552
msgid ""
"Below we can understand the behavior of the Kafka-WS service when a user "
"(through a `user agent`_) requests a ticket in order to establish a "
"communication via websocket with Kafka-WS."
msgstr ""
"Abaixo podemos entender o comportamento do serviço Kafka-WS quando um usuário "
"(por meio de um `user agent`_) solicita um ticket para estabelecer uma "
"comunicação via websocket com Kafka-WS."

#: ../../source/internal-communication.rst:556
msgid ""
"Note that when the user requests a new ticket, Kafka-WS extracts some "
"information from the *user's access token* (`JWT`_) and generates a *signed "
"payload*, to be used later in the decision to authorize (or not) the websocket "
"connection. From the payload a *ticket* is generated and both are stored in "
"Redis, where the ticket is the key to obtain the payload. A `TTL`_ is defined by "
"Kafka-WS, so the user has to use the ticket within the established time, "
"otherwise, Redis automatically deletes the ticket and payload."
msgstr ""
"Observe que quando o usuário solicita um novo ticket, o Kafka-WS extrai algumas "
"informações do *token de acesso do usuário* (`JWT`_) e gera um *payload "
"assinado*, para ser usado posteriormente na decisão de autorizar (ou não) a "
"conexão via websocket. A partir do payload, é gerado um *ticket* e os dois são "
"armazenados no Redis, onde o ticket é a chave para obter o payload. Um `TTL`_ é "
"definido pelo Kafka-WS, então o usuário deve usar o ticket dentro do tempo "
"estabelecido, caso contrário, o Redis apaga automaticamente o ticket e o payload."

#: ../../source/internal-communication.rst:564
msgid ""
"After obtaining the ticket, the user makes an HTTP request to Kafka-WS "
"requesting an upgrade to communicate via *websocket*. As the specification of "
"this HTTP request limits the use of additional headers, it is necessary to send "
"the ticket through the URL, so that it can be validated by Kafka-WS before "
"authorizing the upgrade."
msgstr ""
"Após obter o ticket, o usuário faz uma solicitação HTTP ao Kafka-WS requisitando "
"um upgrade de protocolo para se comunicar via *websocket*. Como a especificação "
"dessa solicitação HTTP limita o uso de cabeçalhos adicionais, é necessário "
"enviar o ticket pela URL, para que possa ser validado pelo Kafka-WS antes de "
"autorizar o upgrade."

#: ../../source/internal-communication.rst:570
msgid ""
"Since the ticket is valid, that is, it corresponds to an entry on Redis, Kafka-"
"WS retrieves the payload related to the ticket, verifies the integrity of the "
"payload and deletes that entry on Redis so that the ticket cannot be used again."
msgstr ""
"Dado que o ticket esteja válido ou seja, corresponde a uma entrada no Redis, o "
"Kafka-WS recupera o payload relacionado ao ticket, verifica sua integridade e "
"exclui essa entrada no Redis para que o ticket não possa ser usado novamente."

#: ../../source/internal-communication.rst:575
msgid ""
"With the payload it is possible to make the decision to authorize the upgrade to "
"websocket or not. If authorization is granted, Kafka-WS opens a subscription "
"channel based on a specific topic in Kafka. From there, the upgrade to websocket "
"is established and the user starts to receive data as they are being published "
"in Kafka."
msgstr ""
"Com o payload é possível tomar a decisão de autorizar ou não o upgrade para "
"websocket. Se a autorização for concedida, o Kafka-WS abre um canal de "
"subscrição com base em um tópico específico no Kafka. A partir daí, o upgrade "
"para websocket é estabelecido e o usuário começa a receber os dados à medida que "
"vão sendo publicados no Kafka."

#: ../../source/internal-communication.rst:581
msgid "Obtaining a ticket and connecting via websocket"
msgstr "Obtenção de ticket e conexão via websocket"
